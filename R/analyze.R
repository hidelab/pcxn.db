# FUNCTION
# - arguments: collection,2 genesets (1 per phenotype), top correlated genesets
# - returns: data.frame which contains the pairs between the phenotype_genesets and their top corralated genesets after filtering. Results are sorted in descending correlation order

# NOTES
# - Collection: only accepting pathprint,MSigDB_H,MSigDB_C2_CP,MSigDB_C5_GO_BP
# - Phenotype_genesets: must belong to the collection and be spelled exactly right!
# - Do we need a search feature that allows the user to search for genesets?
# - If either of the above does not hold, the function specifies which geneset/s do not belong to the collection and also states their phenotype
# - The initial data.frame is filtered by minimum absolute correlation and maximum p-value

analyze <- function(collection = "pathprint",phenotype_0_genesets = c("ABC transporters (KEGG)","ACE Inhibitor Pathway (Wikipathways)","AR down reg. targets (Netpath)"),phenotype_1_genesets = c(), top = 10, min_abs_corr = 0.05, max_pval = 0.05 ) {

  # loading the datasets, when the package is complete we shall use data(...)
  correct_genesets_flag_1 <- TRUE
  correct_genesets_flag_2 <- TRUE

  acceptable_collections = c("pathprint","MSigDB_H","MSigDB_C2_CP","MSigDB_C5_GO_BP")

  if ( collection == "pathprint" ) {
    data(pathCor_pathprint_v1.2.3_dframe)
    matrix <- pathCor_pathprint_v1.2.3_dframe
    data(pathprint.Hs.gs.rda)
    names <- names(pathprint.Hs.gs)
  }
  if ( collection == "MSigDB_H" ) {
    data(pathCor_Hv5.1_dframe)
    matrix <- pathCor_Hv5.1_dframe
    data(h_gs_v5.1)
    names <- names(h_gs_v5.1)
  }
  if ( collection == "MSigDB_C2_CP" ) {
    data(pathCor_CPv5.1_dframe.rda)
    matrix <- pathCor_CPv5.1_dframe
    data(cp_gs_v5.1)
    names <- names(cp_gs_v5.1)
  }
  if ( collection == "MSigDB_C5_GO_BP" ) {
    data(pathCor_GOBPv5.1_dframe)
    matrix <- pathCor_GOBPv5.1_dframe
    data(gobp_gs_v5.1.rda)
    names <- names(gobp_gs_v5.1)
  }

  # Checking if phenotype_genesets are correctly spelled
  commons_0 <- intersect(phenotype_0_genesets, names)
  difs_0 <- c()
  ph_0 <- c()
  if ( length(commons_0) != length(phenotype_0_genesets)) {
    correct_genesets_flag_1 <- FALSE
    difs_0 <- setdiff(phenotype_0_genesets,commons_0)
    ph_0 <- rep(0, length(difs_0))
  }
  commons_1 <- intersect(phenotype_1_genesets, names)
  difs_1 <- c()
  ph_1 <- c()
  if ( length(commons_1) != length(phenotype_1_genesets)) {
    correct_genesets_flag_2 <- FALSE
    difs_1 <- setdiff(phenotype_1_genesets,commons_1)
    ph_1 <- rep(1, length(difs_1))
  }
  difs <- c(difs_0,difs_1)
  phs <- c(ph_0,ph_1)

  # stop if wrong collection inserted or either phenotype genesets does not match the collection
  if(!(collection %in% acceptable_collections)) stop( "Invalid collection name, please choose between: pathprint, MSigDB_H, MSigDB_C2_CP or MSigDB_C5_GO_BP")
  if((correct_genesets_flag_1 == FALSE) || (correct_genesets_flag_2 == FALSE)) stop( paste("Phenotype ",phs," geneset \"",difs,"\" does not belong to the ",collection ," collection\n  ", sep = ""))

  # find un-used genesets and create the placeholder data.frame for their correlation scores
  used_genesets <- c(phenotype_0_genesets,phenotype_1_genesets)
  unused_genesets <- setdiff(names,used_genesets)

  candidate_genesets <- data.frame(unused_genesets)
  candidate_genesets$score <- rep(0,nrow(candidate_genesets))

  # step 1: Filtering on absolute correlation (>=) and p-value (<=)
  step1_matrix <- subset(matrix, abs(PathCor) >= min_abs_corr & p.value <= max_pval)

  # generate score for each un-used geneset and find the top correlated
  for(i in 1:length(unused_genesets)) {
    temp_cor <- subset(step1_matrix,(Pathway.A == unused_genesets[i] | Pathway.B == unused_genesets[i]))
    temp_cor2 <- subset(temp_cor, (Pathway.A %in% used_genesets | Pathway.B %in% used_genesets))
    correlation_vector <- temp_cor2[3]

    if (dim(correlation_vector)[1] != 0) {
      # transpose vector
      correlation_vector <- unname(t(correlation_vector))

      max_position <- which.max(abs(as.numeric(unlist(correlation_vector))))
      max <- correlation_vector[max_position]
      candidate_genesets[i,2] <- max
    }
  }

  candidate_genesets<- candidate_genesets[with(candidate_genesets, order(-abs(candidate_genesets$score))),]
  top_correlated_genesets <- candidate_genesets[,"unused_genesets"][1:top]

  # create matrix with geneset groups
  info <- list(phenotype_0_genesets, phenotype_1_genesets, as.vector(top_correlated_genesets))
  names(info) <- c("phenotype_0_genesets", "phenotype_1_genesets", "top_correlated_genesets")

  # step 2: Find the possible pairs between phenotype_0_genesets,phenotype_1_genesets and correlated genesets.
  interesting_genesets <- c(as.list(used_genesets), as.vector(top_correlated_genesets))

  step2_matrix <- subset(step1_matrix, Pathway.A %in% interesting_genesets & Pathway.B %in% interesting_genesets)

  if(length(phenotype_1_genesets) == 0) print(paste("Successful exploring: Based on phenotype 0 [",paste(phenotype_0_genesets, collapse=', ' ),"] and ",top, " top correlated genesets, ", dim(step2_matrix)[1], " correlation pairs were found.", sep =""))
  else print(paste("Successful exploring: Based on phenotype 0 [",paste(phenotype_0_genesets, collapse=', ' ),"], phenotype 1 [",paste(phenotype_1_genesets, collapse=', ' ),"] and ",top, " top correlated genesets, ", dim(step2_matrix)[1], " correlation pairs were found.", sep =""))

  setClass("pcxn_obj", representation(type = "character" , data = "matrix", geneset_groups = "list"))

  po = new("pcxn_obj",type = "analyze", data = as.matrix(step2_matrix), geneset_groups = as.list(info) )

  return(po)
}